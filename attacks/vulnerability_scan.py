import subprocess
from utils.logger import Logger
from utils.html_logger import HTMLLogger


class VulnerabilityScanner:
    def __init__(self, logger=None):
        self.logger = logger if logger else Logger()

    def identify_services(self, target):
        """
        Identify services and versions running on the target device using `nmap`.

        Parameters:
            target (str): The IP address or hostname of the target device.

        Returns:
            str or None: The raw output of the `nmap` command if successful, otherwise None.

        Raises:
            subprocess.TimeoutExpired: If the service identification exceeds the specified timeout.
            subprocess.CalledProcessError: If the `nmap` command fails or encounters an error.
        """

        try:
            self.logger.log(f"[INFO] Identifying services on target: {target}")
            result = subprocess.run(
                ["sudo", "nmap", "-sV", "-Pn", target],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=60,  # Timeout for nmap service identification
                check=True
            )
            self.logger.log(f"[INFO] Service identification result for {target}:\n{result.stdout}")
            return result.stdout
        except subprocess.TimeoutExpired:
            self.logger.log(f"[WARNING] Nmap service identification timed out for target: {target}")
            return ""
        except subprocess.CalledProcessError as e:
            self.logger.log(f"[ERROR] Failed to identify services for {target}: {e}")
            return ""

        # In run_scan: don’t return early, just log an empty‐result warning
        if not service_data:
            self.logger.log(f"[WARNING] No service data for {target}; will record empty results.")
        if not services:
            self.logger.log(f"[WARNING] No services parsed for {target}; will record empty results.")

    def parse_services(self, service_data):
        """
        Parse the raw output from `nmap` to extract structured service details.

        Parameters:
            service_data (str): The raw output from the `nmap` service identification.

        Returns:
            list: A list of dictionaries where each dictionary contains:
                  - port (str): The port number and protocol (e.g., "80/tcp").
                  - name (str): The name of the service running on the port.
                  - version (str): The version of the service (if available).
        """

        services = []
        for line in service_data.splitlines():
            if "open" in line and "/" in line:
                try:
                    parts = line.split()
                    port = parts[0]
                    service_name = parts[2] if len(parts) > 2 else "unknown"
                    version = " ".join(parts[3:]) if len(parts) > 3 else "unknown"
                    services.append({"port": port, "name": service_name, "version": version})
                    self.logger.log(f"[DEBUG] Parsed service - Port: {port}, Name: {service_name}, Version: {version}")
                except Exception as e:
                    self.logger.log(f"[WARNING] Failed to parse service line: {line} - {e}")
        return services

    def lookup_vulnerabilities(self, services):
        """
        Look up vulnerabilities for identified services using `searchsploit`.

        Parameters:
            services (list): A list of dictionaries containing service details, including:
                             - port (str): The port number and protocol.
                             - name (str): The name of the service.
                             - version (str): The version of the service.

        Returns:
            list: A list of dictionaries where each dictionary contains:
                  - port (str): The port number and protocol.
                  - name (str): The name of the service.
                  - version (str): The version of the service.
                  - vulnerabilities (str or None): The searchsploit output for the service, or None if no vulnerabilities were found.

        Raises:
            subprocess.TimeoutExpired: If the `searchsploit` command exceeds the specified timeout.
            subprocess.CalledProcessError: If the `searchsploit` command fails or encounters an error.
        """

        self.logger.log(f"[INFO] Looking up vulnerabilities for identified services.")
        vulnerabilities = []

        for service in services:
            search_term = f"{service['name']} {service['version']}"
            self.logger.log(f"[INFO] Checking vulnerabilities for service: {search_term} on port {service['port']}")

            try:
                result = subprocess.run(
                    ["searchsploit", search_term],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    timeout=30  # Timeout for searchsploit calls
                )
                if result.stdout.strip():
                    self.logger.log(f"[INFO] Vulnerabilities found for {search_term}:\n{result.stdout}")
                    service["vulnerabilities"] = result.stdout.strip()
                else:
                    self.logger.log(f"[INFO] No vulnerabilities found for {search_term}.")
                    service["vulnerabilities"] = None
            except subprocess.TimeoutExpired:
                self.logger.log(f"[WARNING] Searchsploit timed out for service: {search_term}")
                service["vulnerabilities"] = None
            except subprocess.CalledProcessError as e:
                self.logger.log(f"[ERROR] Error while searching vulnerabilities: {e}")
                service["vulnerabilities"] = None

            vulnerabilities.append(service)

        return vulnerabilities

    def run_scan(self, target, ssid=None, html_logger=None):
        """
        Run a full vulnerability scan on the target device.

        Parameters:
            target (str): The IP address or hostname of the target device.
            ssid (str, optional): The SSID of the current Wi-Fi network.
            html_logger (HTMLLogger, optional): An instance of the HTMLLogger class for recording results.

        Workflow:
            1. Identify services and versions running on the target.
            2. Parse the identified services for structured details.
            3. Look up vulnerabilities for each identified service.
            4. Log the scan results and optionally append them to an HTML report.

        Returns:
            dict: A dictionary containing the scan results, including:
                  - target (str): The target IP or hostname.
                  - vulnerabilities (list): A list of dictionaries with vulnerability details.

        Raises:
            Exception: If any critical error occurs during the vulnerability scan process.
        """

        self.logger.log(f"[INFO] Starting vulnerability scan on target: {target}")

        # Step 1: Identify services
        service_data = self.identify_services(target)
        if not service_data:
            self.logger.log(f"[ERROR] No services identified on target: {target}. Aborting vulnerability scan.")
            return

        # Step 2: Parse services and look up vulnerabilities
        services = self.parse_services(service_data)
        if not services:
            self.logger.log(f"[WARNING] No services found on target: {target}.")
            return

        vulnerabilities = self.lookup_vulnerabilities(services)

        # Step 3: Log and save results
        scan_results = {
            "target": target,
            "vulnerabilities": vulnerabilities,
        }

        self.logger.log(f"[INFO] Vulnerability scan completed for target: {target}")

        # Append results to HTML log
        if html_logger and ssid:
            html_logger.append_vulnerability_results_to_html(ssid, scan_results)

        return scan_results
